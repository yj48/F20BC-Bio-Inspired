function xbest = MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% samples new points uniformly randomly in [-5,5]^DIM
% and evaluates them on FUN until ftarget of maxfunevals
% is reached, or until 1e8 * DIM fevals are conducted. 

  maxfunevals = min(1e8 * DIM, maxfunevals); 
  popsize = min(maxfunevals, 200);
  fbest = inf;
  for iter = 1:ceil(maxfunevals/popsize)
    xpop = 10 * rand(DIM, popsize) - 5;      % new solutions
    [fvalues, idx] = sort(feval(FUN, xpop)); % evaluate - This is the fitness function used by genetic algorithm
    if fbest > fvalues(1)                    % keep best
      fbest = fvalues(1);
      xbest = xpop(:,idx(1));
      generated(iter) = xbest;
    end
    if feval(FUN, 'fbest') < ftarget         % COCO-task achieved
      break;                                 % (works also for noisy functions)
    end
  end 
  
  plotdata(generated,generated,ceil(maxfunevals/popsize));

  
function xbest = MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% samples new points uniformly randomly in [-5,5]^DIM
% and evaluates them on FUN until ftarget of maxfunevals
% is reached, or until 1e8 * DIM fevals are conducted.

hidden_node = zeros(1,5);
input_node = [10,5];
output_node = [0,0];

[hr,hc] = size(hidden_node); %hr = hidden rows (1), hc = hidden columns (5)
[ir,ic] = size(input_node);
[or,oc] = size(output_node);

rand_max = 0.5; %range of random values
rand_min = -0.5; %used for weight initialisation

weight_input = zeros(ic,hc); %This is filling an array with zeros of the correct size
weight_output = zeros(hc,oc);

[wir,wic] = size(weight_input);
[wor,woc] = size(weight_output);

maxfunevals = min(1e8 * DIM, maxfunevals);
fbest = inf;

for i = 1:ic           %initialise input->hidden weights to random values
    for j = 1:hc
        r = rand_min + (rand_max-rand_min)*rand(1,1);
        weight_input(i,j) = r;
    end
end

for i = 1:hc          %initialise ouput->hidden weights to random values
    for j = 1:oc
        r = rand_min + (rand_max-rand_min)*rand(1,1); %create a random number between rand_min and rand_max
        weight_output(i,j) = r;
    end
end

for iter = 1:ceil(maxfunevals/popsize)
    
     for i = 1:wic
        for j = 1:wir
            hidden_node(i) = hidden_node(i)+weight_input(j,i).*input_node(j);
        end
        hidden_node(i) = logsig(hidden_node(i));
    end
    
    for i = 1:woc
        for j = 1:wor
            output_node(i) = output_node(i)+weight_input(i,j).*hidden_node(j);
        end
    end
    
    [fvalues, idx] = sort(feval(FUN, output_node)); % evaluate - This is the fitness function used by genetic algorithm
    
    
    if feval(FUN, 'fbest') < ftarget         % COCO-task achieved
        break;                                 % (works also for noisy functions)
    end
end


function xbest = MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% MY_OPTIMIZER(FUN, DIM, ftarget, maxfunevals)
% samples new points uniformly randomly in [-5,5]^DIM
% and evaluates them on FUN until ftarget of maxfunevals
% is reached, or until 1e8 * DIM fevals are conducted.

%TO CHANGE WHEN CHANGING STRUCTURE:

    %Structure of nodes using NODES
    %Value of input nodes in node_layer_1
    %Number of solutions generated from genetic algorithm
    %Changeable constants defined in capitals

%INPUT_NODES = [10,5];        %Fairly sure this isn't right, should this not be dimensions similar? ie [2,3] or [6,14

INPUT_NODES = 10 * rand(1, DIM) - 5;      % new solutions
    %Assigning values for input nodes 
GA_SOLUTIONS_SIZE = 20;
NODES = [DIM,5,5,7,2,DIM,0];       %CONSTANT NUMBER OF HIDDEN NODES
    %Matrix reGA_SOLUTIONS_SIZEesentation of layers
    %[2,5,2,0,0,0,0] specifies a neural network with 2 input nodes, 5
    %hidden nodes on one layer and 2 output nodes. Each array must have 7
    %values, max 5 hidden layers allowed
    
maxfunevals = min(1e8 * DIM, maxfunevals);
popsize = min(maxfunevals, 200);

%Main body of code: all stems from above capitalised user-defined variables
    
node_layer_1 = INPUT_NODES;
    
    [tr,tc] = size(node_layer_1);
    if(NODES(1)~=tc)
        error('Number of input nodes do not match input nodes value definition');
    end

weights_total = NODES(1)*NODES(2) + NODES(2)*NODES(3) + NODES(3)*NODES(4) + NODES(4)*NODES(5) + NODES(5)*NODES(6) + NODES(6)*NODES(7);
    %Calculating number of weights generated by connections between nodes

population_ga = zeros(GA_SOLUTIONS_SIZE,weights_total);      %Genetic algorithm section
population_ga = genetic_initialise(population_ga); %Initialise with random numbers
 
    %Rows = population size in genetic algorithm
    %Columns = Size of weights solution (chromosome)

for i = 1:7
   if(NODES(i)==0)
       hc = i-1;
       output_size = (NODES(i-1));
       break;
   end
end


if (hc == 3) %Creating node_layer matrices with nodes
%   node_layer_1 = zeros(1,NODES(1,1));
   node_layer_2 = zeros(1,NODES(1,2));
   node_layer_3 = zeros(1,NODES(1,3));
   node_layer_4 = [];
   node_layer_5 = [];
   node_layer_6 = [];
   node_layer_7 = [];
elseif (hc == 4)
%   node_layer_1 = zeros(1,NODES(1,1));
   node_layer_2 = zeros(1,NODES(1,2));
   node_layer_3 = zeros(1,NODES(1,3));
   node_layer_4 = zeros(1,NODES(1,4));
   node_layer_5 = [];
   node_layer_6 = [];
   node_layer_7 = [];
elseif (hc == 5)
%   node_layer_1 = zeros(1,NODES(1,1));
   node_layer_2 = zeros(1,NODES(1,2));
   node_layer_3 = zeros(1,NODES(1,3));
   node_layer_4 = zeros(1,NODES(1,4));
   node_layer_5 = zeros(1,NODES(1,5));
   node_layer_6 = [];
   node_layer_7 = [];
elseif (hc == 6)
%   node_layer_1 = zeros(1,NODES(1,1));
   node_layer_2 = zeros(1,NODES(1,2));
   node_layer_3 = zeros(1,NODES(1,3));
   node_layer_4 = zeros(1,NODES(1,4));
   node_layer_5 = zeros(1,NODES(1,5));
   node_layer_6 = zeros(1,NODES(1,6));
   node_layer_7 = [];
elseif (hc == 7)
%   node_layer_1 = zeros(1,NODES(1,1));
   node_layer_2 = zeros(1,NODES(1,2));
   node_layer_3 = zeros(1,NODES(1,3));
   node_layer_4 = zeros(1,NODES(1,4));
   node_layer_5 = zeros(1,NODES(1,5));
   node_layer_6 = zeros(1,NODES(1,6));
   node_layer_7 = zeros(1,NODES(1,7));
end    

solution_storage = zeros(output_size,GA_SOLUTIONS_SIZE);

[n1r,n1c] = size(node_layer_1);
[n2r,n2c] = size(node_layer_2);
[n3r,n3c] = size(node_layer_3);
[n4r,n4c] = size(node_layer_4);
[n5r,n5c] = size(node_layer_5);
[n6r,n6c] = size(node_layer_6);
[n7r,n7c] = size(node_layer_7);

rand_max = 0.5; %range of random values
rand_min = -0.5; %used for weight initialisation

weights_i1 = zeros(n1c,n2c);
weights_12 = zeros(n2c,n3c);
weights_23 = zeros(n3c,n4c);
weights_34 = zeros(n4c,n5c);
weights_45 = zeros(n5c,n6c);
weights_5o = zeros(n6c,n7c);

fbest = inf;

for chromosome = 1:GA_SOLUTIONS_SIZE
    [weights_i1,weights_12,weights_23,weights_34,weights_45,weights_5o] = concatenate_weights(n1c,n2c,n3c,n4c,n5c,n6c,n7r,population_ga(chromosome,:));
    solution_storage(:,chromosome) = neural_network_iteration(node_layer_1,weights_i1,weights_12,weights_23,weights_34,weights_45,weights_5o);
end

xpop = solution_storage;
[fvalues, idx] = sort(feval(FUN, xpop)); % evaluate - This is the fitness function used by genetic algorithm

%population_ga = genetic_reproduction(population_ga,idx);    %Initial crossover and mutate of the function
%population_ga = genetic_mutation(population_ga,idx);

banan = feval(FUN,xpop);
banana = banan;

for iter = 1:ceil(maxfunevals/popsize)
    
    
     xpop = 10 * rand(DIM, popsize) - 5;      % new solutions
    [fvalues, idx] = sort(feval(FUN, xpop)); % evaluate - This is the fitness function used by genetic algorithm
    
    
    %For each chromosome (weight solution) in GA, iterate through Neural
    %Network and store the result
     for chromosome = 1:pr
         [weight_input,weight_output] = concatenate_weights(2,5,2,population_ga(chromosome,:));
         solution_storage(:,iter) = neural_network_iteration(input_node,weight_input,hidden_node,weight_output,output_node);
     end
     
     xpop = solution_storage; %solution_storage not needed - could go directly in xpop
                             %Just a double check for now
                                  
     [fvalues, idx] = sort(feval(FUN, xpop)); % evaluate - This is the fitness function used by genetic algorithm
    
    if fbest > fvalues(1) % keep best
        fbest = fvalues(1);
        xbest = xpop(:,idx(1));
    end
    
    population_ga = genetic_reproduction(population_ga,idx); %Create new population from fitnesses using genetic algorithm
    population_ga = genetic_mutation(population_ga,idx); %May want to store these at some point, (ie compare old to new)
        %Not necessary right now
    
    if feval(FUN, 'fbest') < ftarget         % COCO-task achieved
        break;                                 % (works also for noisy functions)
    end
    %Still not entirely sure why this is there but leaving it for now
    
end

boo = fvalues; %Just a check, debugging alone
index = idx;
best = fbest;
pop = xpop;
best = xbest;

